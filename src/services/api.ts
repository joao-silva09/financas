//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.17.0.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, {
  AxiosError,
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  CancelToken,
} from "axios";

export class Client {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Cadastrar um novo usuário.
   * @param body (optional)
   * @return Success
   */
  register(
    body: UsuarioRegisterDto | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<Int32ServiceResponse> {
    let url_ = this.baseUrl + "/Auth/register";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRegister(_response);
      });
  }

  protected processRegister(
    response: AxiosResponse
  ): Promise<Int32ServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = Int32ServiceResponse.fromJS(resultData200);
      return Promise.resolve<Int32ServiceResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<Int32ServiceResponse>(null as any);
  }

  /**
   * Fazer login.
   * @param body (optional)
   * @return Success
   */
  login(
    body: UsuarioLoginDto | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<StringServiceResponse> {
    let url_ = this.baseUrl + "/Auth/login";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processLogin(_response);
      });
  }

  protected processLogin(
    response: AxiosResponse
  ): Promise<StringServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = StringServiceResponse.fromJS(resultData200);
      return Promise.resolve<StringServiceResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<StringServiceResponse>(null as any);
  }

  /**
   * Buscar todas as contas do usuário.
   * @return Success
   */
  getAll(
    cancelToken?: CancelToken | undefined
  ): Promise<GetContaDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Conta/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAll(_response);
      });
  }

  protected processGetAll(
    response: AxiosResponse
  ): Promise<GetContaDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetContaDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetContaDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetContaDtoListServiceResponse>(null as any);
  }

  /**
   * Buscar uma conta por id.
   * @return Success
   */
  contaGET(
    id: number,
    cancelToken?: CancelToken | undefined
  ): Promise<GetContaDtoServiceResponse> {
    let url_ = this.baseUrl + "/api/Conta/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processContaGET(_response);
      });
  }

  protected processContaGET(
    response: AxiosResponse
  ): Promise<GetContaDtoServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetContaDtoServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetContaDtoServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetContaDtoServiceResponse>(null as any);
  }

  /**
   * Excluir uma conta.
   * @return Success
   */
  contaDELETE(
    id: number,
    cancelToken?: CancelToken | undefined
  ): Promise<GetContaDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Conta/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "DELETE",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processContaDELETE(_response);
      });
  }

  protected processContaDELETE(
    response: AxiosResponse
  ): Promise<GetContaDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetContaDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetContaDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetContaDtoListServiceResponse>(null as any);
  }

  /**
   * Adicionar uma nova conta.
   * @param body (optional)
   * @return Success
   */
  contaPOST(
    body: AddContaDto | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<GetContaDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Conta";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processContaPOST(_response);
      });
  }

  protected processContaPOST(
    response: AxiosResponse
  ): Promise<GetContaDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetContaDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetContaDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetContaDtoListServiceResponse>(null as any);
  }

  /**
   * Atualizar as informações de uma conta.
   * @param body (optional)
   * @return Success
   */
  contaPUT(
    body: UpdateContaDto | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<GetContaDtoServiceResponse> {
    let url_ = this.baseUrl + "/api/Conta";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processContaPUT(_response);
      });
  }

  protected processContaPUT(
    response: AxiosResponse
  ): Promise<GetContaDtoServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetContaDtoServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetContaDtoServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetContaDtoServiceResponse>(null as any);
  }

  /**
   * Buscar todas as dívidas do usuário.
   * @return Success
   */
  getAll2(
    cancelToken?: CancelToken | undefined
  ): Promise<GetDividaDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Divida/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAll2(_response);
      });
  }

  protected processGetAll2(
    response: AxiosResponse
  ): Promise<GetDividaDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetDividaDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetDividaDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetDividaDtoListServiceResponse>(null as any);
  }

  /**
   * Buscar uma dívida por id.
   * @return Success
   */
  dividaGET(
    id: number,
    cancelToken?: CancelToken | undefined
  ): Promise<GetDividaDtoServiceResponse> {
    let url_ = this.baseUrl + "/api/Divida/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDividaGET(_response);
      });
  }

  protected processDividaGET(
    response: AxiosResponse
  ): Promise<GetDividaDtoServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetDividaDtoServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetDividaDtoServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetDividaDtoServiceResponse>(null as any);
  }

  /**
   * Excluir uma dívida.
   * @return Success
   */
  dividaDELETE(
    id: number,
    cancelToken?: CancelToken | undefined
  ): Promise<GetDividaDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Divida/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "DELETE",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDividaDELETE(_response);
      });
  }

  protected processDividaDELETE(
    response: AxiosResponse
  ): Promise<GetDividaDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetDividaDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetDividaDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetDividaDtoListServiceResponse>(null as any);
  }

  /**
   * Buscar todas as dívidas a pagar.
   * @return Success
   */
  aPagar(
    cancelToken?: CancelToken | undefined
  ): Promise<GetDividaDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Divida/Get/APagar";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAPagar(_response);
      });
  }

  protected processAPagar(
    response: AxiosResponse
  ): Promise<GetDividaDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetDividaDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetDividaDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetDividaDtoListServiceResponse>(null as any);
  }

  /**
   * Buscar todas as dívidas a receber.
   * @return Success
   */
  aReceber(
    cancelToken?: CancelToken | undefined
  ): Promise<GetDividaDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Divida/Get/AReceber";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAReceber(_response);
      });
  }

  protected processAReceber(
    response: AxiosResponse
  ): Promise<GetDividaDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetDividaDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetDividaDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetDividaDtoListServiceResponse>(null as any);
  }

  /**
   * Buscar todas as dívidas pagas.
   * @return Success
   */
  pagas(
    cancelToken?: CancelToken | undefined
  ): Promise<GetDividaDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Divida/Get/pagas";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPagas(_response);
      });
  }

  protected processPagas(
    response: AxiosResponse
  ): Promise<GetDividaDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetDividaDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetDividaDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetDividaDtoListServiceResponse>(null as any);
  }

  /**
   * Adicionar uma nova dívida.
   * @param body (optional)
   * @return Success
   */
  dividaPOST(
    body: AddDividaDto | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<GetDividaDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Divida";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDividaPOST(_response);
      });
  }

  protected processDividaPOST(
    response: AxiosResponse
  ): Promise<GetDividaDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetDividaDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetDividaDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetDividaDtoListServiceResponse>(null as any);
  }

  /**
   * Atualizar as informações de uma dívida.
   * @param body (optional)
   * @return Success
   */
  dividaPUT(
    body: UpdateDividaDto | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<GetDividaDtoServiceResponse> {
    let url_ = this.baseUrl + "/api/Divida";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDividaPUT(_response);
      });
  }

  protected processDividaPUT(
    response: AxiosResponse
  ): Promise<GetDividaDtoServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetDividaDtoServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetDividaDtoServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetDividaDtoServiceResponse>(null as any);
  }

  /**
   * Pagar uma dívida.
   * @param body (optional)
   * @return Success
   */
  pagar(
    dividaId: number,
    body: PagarDividaDto | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<GetDividaDtoListServiceResponse> {
    let url_ = this.baseUrl + "/Pagar/{dividaId}";
    if (dividaId === undefined || dividaId === null)
      throw new Error("The parameter 'dividaId' must be defined.");
    url_ = url_.replace("{dividaId}", encodeURIComponent("" + dividaId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPagar(_response);
      });
  }

  protected processPagar(
    response: AxiosResponse
  ): Promise<GetDividaDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetDividaDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetDividaDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetDividaDtoListServiceResponse>(null as any);
  }

  /**
   * Buscar todos os objetivos.
   * @return Success
   */
  getAll3(
    cancelToken?: CancelToken | undefined
  ): Promise<GetObjetivoDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Objetivo/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAll3(_response);
      });
  }

  protected processGetAll3(
    response: AxiosResponse
  ): Promise<GetObjetivoDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetObjetivoDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetObjetivoDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetObjetivoDtoListServiceResponse>(null as any);
  }

  /**
   * Buscar objetivos a cumprir.
   * @return Success
   */
  aCumprir(
    cancelToken?: CancelToken | undefined
  ): Promise<GetObjetivoDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Objetivo/Get/aCumprir";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processACumprir(_response);
      });
  }

  protected processACumprir(
    response: AxiosResponse
  ): Promise<GetObjetivoDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetObjetivoDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetObjetivoDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetObjetivoDtoListServiceResponse>(null as any);
  }

  /**
   * Buscar objetivos cumpridos.
   * @return Success
   */
  cumpridos(
    cancelToken?: CancelToken | undefined
  ): Promise<GetObjetivoDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Objetivo/GetAll/cumpridos";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCumpridos(_response);
      });
  }

  protected processCumpridos(
    response: AxiosResponse
  ): Promise<GetObjetivoDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetObjetivoDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetObjetivoDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetObjetivoDtoListServiceResponse>(null as any);
  }

  /**
   * Buscar um objetivo por id.
   * @return Success
   */
  objetivoGET(
    id: number,
    cancelToken?: CancelToken | undefined
  ): Promise<GetObjetivoDtoServiceResponse> {
    let url_ = this.baseUrl + "/api/Objetivo/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processObjetivoGET(_response);
      });
  }

  protected processObjetivoGET(
    response: AxiosResponse
  ): Promise<GetObjetivoDtoServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetObjetivoDtoServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetObjetivoDtoServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetObjetivoDtoServiceResponse>(null as any);
  }

  /**
   * Excluir um objetivo.
   * @return Success
   */
  objetivoDELETE(
    id: number,
    cancelToken?: CancelToken | undefined
  ): Promise<GetObjetivoDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Objetivo/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "DELETE",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processObjetivoDELETE(_response);
      });
  }

  protected processObjetivoDELETE(
    response: AxiosResponse
  ): Promise<GetObjetivoDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetObjetivoDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetObjetivoDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetObjetivoDtoListServiceResponse>(null as any);
  }

  /**
   * Criar um novo objetivo.
   * @param body (optional)
   * @return Success
   */
  objetivoPOST(
    body: AddObjetivoDto | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<GetObjetivoDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Objetivo";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processObjetivoPOST(_response);
      });
  }

  protected processObjetivoPOST(
    response: AxiosResponse
  ): Promise<GetObjetivoDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetObjetivoDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetObjetivoDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetObjetivoDtoListServiceResponse>(null as any);
  }

  /**
   * Atualizar as informações de um objetivo.
   * @param body (optional)
   * @return Success
   */
  objetivoPUT(
    body: UpdateObjetivoDto | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<GetObjetivoDtoServiceResponse> {
    let url_ = this.baseUrl + "/api/Objetivo";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processObjetivoPUT(_response);
      });
  }

  protected processObjetivoPUT(
    response: AxiosResponse
  ): Promise<GetObjetivoDtoServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetObjetivoDtoServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetObjetivoDtoServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetObjetivoDtoServiceResponse>(null as any);
  }

  /**
   * Cumprir um objetivo.
   * @return Success
   */
  objetivoPOST2(
    objetivoId: number,
    contaId: number,
    cancelToken?: CancelToken | undefined
  ): Promise<GetObjetivoDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Objetivo/{objetivoId}/{contaId}";
    if (objetivoId === undefined || objetivoId === null)
      throw new Error("The parameter 'objetivoId' must be defined.");
    url_ = url_.replace("{objetivoId}", encodeURIComponent("" + objetivoId));
    if (contaId === undefined || contaId === null)
      throw new Error("The parameter 'contaId' must be defined.");
    url_ = url_.replace("{contaId}", encodeURIComponent("" + contaId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "POST",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processObjetivoPOST2(_response);
      });
  }

  protected processObjetivoPOST2(
    response: AxiosResponse
  ): Promise<GetObjetivoDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetObjetivoDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetObjetivoDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetObjetivoDtoListServiceResponse>(null as any);
  }

  /**
   * Buscar todas as operações.
   * @return Success
   */
  getAll4(
    cancelToken?: CancelToken | undefined
  ): Promise<GetOperacaoDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Operacao/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAll4(_response);
      });
  }

  protected processGetAll4(
    response: AxiosResponse
  ): Promise<GetOperacaoDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetOperacaoDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetOperacaoDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetOperacaoDtoListServiceResponse>(null as any);
  }

  /**
   * Buscar todas as operações de um determinado mês.
   * @return Success
   */
  get(
    month: number,
    year: number,
    cancelToken?: CancelToken | undefined
  ): Promise<GetOperacaoDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Operacao/Get/{month}/{year}";
    if (month === undefined || month === null)
      throw new Error("The parameter 'month' must be defined.");
    url_ = url_.replace("{month}", encodeURIComponent("" + month));
    if (year === undefined || year === null)
      throw new Error("The parameter 'year' must be defined.");
    url_ = url_.replace("{year}", encodeURIComponent("" + year));
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGet(_response);
      });
  }

  protected processGet(
    response: AxiosResponse
  ): Promise<GetOperacaoDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetOperacaoDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetOperacaoDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetOperacaoDtoListServiceResponse>(null as any);
  }

  /**
   * Buscar todas as operações de um determinado mês e tipo.
   * @return Success
   */
  get2(
    month: number,
    year: number,
    type: TipoOperacao,
    cancelToken?: CancelToken | undefined
  ): Promise<GetOperacaoDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Operacao/Get/{month}/{year}/{type}";
    if (month === undefined || month === null)
      throw new Error("The parameter 'month' must be defined.");
    url_ = url_.replace("{month}", encodeURIComponent("" + month));
    if (year === undefined || year === null)
      throw new Error("The parameter 'year' must be defined.");
    url_ = url_.replace("{year}", encodeURIComponent("" + year));
    if (type === undefined || type === null)
      throw new Error("The parameter 'type' must be defined.");
    url_ = url_.replace("{type}", encodeURIComponent("" + type));
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGet2(_response);
      });
  }

  protected processGet2(
    response: AxiosResponse
  ): Promise<GetOperacaoDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetOperacaoDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetOperacaoDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetOperacaoDtoListServiceResponse>(null as any);
  }

  /**
   * Buscar todas as operações de uma conta.
   * @return Success
   */
  conta(
    contaId: number,
    cancelToken?: CancelToken | undefined
  ): Promise<GetOperacaoDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Operacao/conta/{contaId}";
    if (contaId === undefined || contaId === null)
      throw new Error("The parameter 'contaId' must be defined.");
    url_ = url_.replace("{contaId}", encodeURIComponent("" + contaId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processConta(_response);
      });
  }

  protected processConta(
    response: AxiosResponse
  ): Promise<GetOperacaoDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetOperacaoDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetOperacaoDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetOperacaoDtoListServiceResponse>(null as any);
  }

  /**
   * Buscar uma única operação.
   * @return Success
   */
  operacaoGET(
    id: number,
    cancelToken?: CancelToken | undefined
  ): Promise<GetOperacaoDtoServiceResponse> {
    let url_ = this.baseUrl + "/api/Operacao/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processOperacaoGET(_response);
      });
  }

  protected processOperacaoGET(
    response: AxiosResponse
  ): Promise<GetOperacaoDtoServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetOperacaoDtoServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetOperacaoDtoServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetOperacaoDtoServiceResponse>(null as any);
  }

  /**
   * Excluir uma operação.
   * @return Success
   */
  operacaoDELETE(
    id: number,
    cancelToken?: CancelToken | undefined
  ): Promise<GetOperacaoDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Operacao/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "DELETE",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processOperacaoDELETE(_response);
      });
  }

  protected processOperacaoDELETE(
    response: AxiosResponse
  ): Promise<GetOperacaoDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetOperacaoDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetOperacaoDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetOperacaoDtoListServiceResponse>(null as any);
  }

  /**
   * Adicionar uma nova operação de gasto.
   * @param body (optional)
   * @return Success
   */
  gasto(
    contaId: number,
    body: AddOperacaoDto | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<GetOperacaoDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Operacao/gasto/{contaId}";
    if (contaId === undefined || contaId === null)
      throw new Error("The parameter 'contaId' must be defined.");
    url_ = url_.replace("{contaId}", encodeURIComponent("" + contaId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGasto(_response);
      });
  }

  protected processGasto(
    response: AxiosResponse
  ): Promise<GetOperacaoDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetOperacaoDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetOperacaoDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetOperacaoDtoListServiceResponse>(null as any);
  }

  /**
   * Atualizar as infomações de uma operação.
   * @param body (optional)
   * @return Success
   */
  operacaoPUT(
    body: UpdateOperacaoDto | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<GetOperacaoDtoServiceResponse> {
    let url_ = this.baseUrl + "/api/Operacao";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processOperacaoPUT(_response);
      });
  }

  protected processOperacaoPUT(
    response: AxiosResponse
  ): Promise<GetOperacaoDtoServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetOperacaoDtoServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetOperacaoDtoServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetOperacaoDtoServiceResponse>(null as any);
  }

  /**
   * Adicionar uma nova operação de receita.
   * @param body (optional)
   * @return Success
   */
  receita(
    contaId: number,
    body: AddOperacaoDto | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<GetOperacaoDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Operacao/receita/{contaId}";
    if (contaId === undefined || contaId === null)
      throw new Error("The parameter 'contaId' must be defined.");
    url_ = url_.replace("{contaId}", encodeURIComponent("" + contaId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processReceita(_response);
      });
  }

  protected processReceita(
    response: AxiosResponse
  ): Promise<GetOperacaoDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetOperacaoDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetOperacaoDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetOperacaoDtoListServiceResponse>(null as any);
  }

  /**
   * Adicionar uma nova operação.
   * @param body (optional)
   * @return Success
   */
  operacaoPOST(
    contaId: number,
    body: AddOperacaoDto | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<GetOperacaoDtoListServiceResponse> {
    let url_ = this.baseUrl + "/api/Operacao/{contaId}";
    if (contaId === undefined || contaId === null)
      throw new Error("The parameter 'contaId' must be defined.");
    url_ = url_.replace("{contaId}", encodeURIComponent("" + contaId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processOperacaoPOST(_response);
      });
  }

  protected processOperacaoPOST(
    response: AxiosResponse
  ): Promise<GetOperacaoDtoListServiceResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetOperacaoDtoListServiceResponse.fromJS(resultData200);
      return Promise.resolve<GetOperacaoDtoListServiceResponse>(result200);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetOperacaoDtoListServiceResponse>(null as any);
  }
}

export class AddContaDto implements IAddContaDto {
  titulo?: string | undefined;
  saldo?: number;
  banco?: Banco;

  constructor(data?: IAddContaDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.titulo = _data["titulo"];
      this.saldo = _data["saldo"];
      this.banco = _data["banco"];
    }
  }

  static fromJS(data: any): AddContaDto {
    data = typeof data === "object" ? data : {};
    let result = new AddContaDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["titulo"] = this.titulo;
    data["saldo"] = this.saldo;
    data["banco"] = this.banco;
    return data;
  }
}

export interface IAddContaDto {
  titulo?: string | undefined;
  saldo?: number;
  banco?: Banco;
}

export class AddDividaDto implements IAddDividaDto {
  titulo?: string | undefined;
  nomeDevedor?: string | undefined;
  descricao?: string | undefined;
  valor?: number;
  dataVencimento?: Date | undefined;
  tipoDivida?: TipoDivida;

  constructor(data?: IAddDividaDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.titulo = _data["titulo"];
      this.nomeDevedor = _data["nomeDevedor"];
      this.descricao = _data["descricao"];
      this.valor = _data["valor"];
      this.dataVencimento = _data["dataVencimento"]
        ? new Date(_data["dataVencimento"].toString())
        : <any>undefined;
      this.tipoDivida = _data["tipoDivida"];
    }
  }

  static fromJS(data: any): AddDividaDto {
    data = typeof data === "object" ? data : {};
    let result = new AddDividaDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["titulo"] = this.titulo;
    data["nomeDevedor"] = this.nomeDevedor;
    data["descricao"] = this.descricao;
    data["valor"] = this.valor;
    data["dataVencimento"] = this.dataVencimento
      ? this.dataVencimento.toISOString()
      : <any>undefined;
    data["tipoDivida"] = this.tipoDivida;
    return data;
  }
}

export interface IAddDividaDto {
  titulo?: string | undefined;
  nomeDevedor?: string | undefined;
  descricao?: string | undefined;
  valor?: number;
  dataVencimento?: Date | undefined;
  tipoDivida?: TipoDivida;
}

export class AddObjetivoDto implements IAddObjetivoDto {
  titulo?: string | undefined;
  descricao?: string | undefined;
  valor?: number;
  situacaoObjetivo?: SituacaoObjetivo;

  constructor(data?: IAddObjetivoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.titulo = _data["titulo"];
      this.descricao = _data["descricao"];
      this.valor = _data["valor"];
      this.situacaoObjetivo = _data["situacaoObjetivo"];
    }
  }

  static fromJS(data: any): AddObjetivoDto {
    data = typeof data === "object" ? data : {};
    let result = new AddObjetivoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["titulo"] = this.titulo;
    data["descricao"] = this.descricao;
    data["valor"] = this.valor;
    data["situacaoObjetivo"] = this.situacaoObjetivo;
    return data;
  }
}

export interface IAddObjetivoDto {
  titulo?: string | undefined;
  descricao?: string | undefined;
  valor?: number;
  situacaoObjetivo?: SituacaoObjetivo;
}

export class AddOperacaoDto implements IAddOperacaoDto {
  titulo?: string | undefined;
  descricao?: string | undefined;
  valor?: number;
  dataOperacao?: Date | undefined;
  tipoOperacao?: TipoOperacao;

  constructor(data?: IAddOperacaoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.titulo = _data["titulo"];
      this.descricao = _data["descricao"];
      this.valor = _data["valor"];
      this.dataOperacao = _data["dataOperacao"]
        ? new Date(_data["dataOperacao"].toString())
        : <any>undefined;
      this.tipoOperacao = _data["tipoOperacao"];
    }
  }

  static fromJS(data: any): AddOperacaoDto {
    data = typeof data === "object" ? data : {};
    let result = new AddOperacaoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["titulo"] = this.titulo;
    data["descricao"] = this.descricao;
    data["valor"] = this.valor;
    data["dataOperacao"] = this.dataOperacao
      ? this.dataOperacao.toISOString()
      : <any>undefined;
    data["tipoOperacao"] = this.tipoOperacao;
    return data;
  }
}

export interface IAddOperacaoDto {
  titulo?: string | undefined;
  descricao?: string | undefined;
  valor?: number;
  dataOperacao?: Date | undefined;
  tipoOperacao?: TipoOperacao;
}

export enum Banco {
  Bradesco = "Bradesco",
  Itaú = "Itaú",
  Santander = "Santander",
  Banco_Do_Brasil = "Banco_Do_Brasil",
  Caixa = "Caixa",
  Sicredi = "Sicredi",
  Sicoob = "Sicoob",
  Nubank = "Nubank",
  Inter = "Inter",
  C6_bank = "C6_bank",
  PicPay = "PicPay",
  Carteira_Física = "Carteira_Física",
  Outros = "Outros",
}

export class GetContaDto implements IGetContaDto {
  id?: number;
  titulo?: string | undefined;
  saldo?: number;
  banco?: Banco;

  constructor(data?: IGetContaDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.titulo = _data["titulo"];
      this.saldo = _data["saldo"];
      this.banco = _data["banco"];
    }
  }

  static fromJS(data: any): GetContaDto {
    data = typeof data === "object" ? data : {};
    let result = new GetContaDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["titulo"] = this.titulo;
    data["saldo"] = this.saldo;
    data["banco"] = this.banco;
    return data;
  }
}

export interface IGetContaDto {
  id?: number;
  titulo?: string | undefined;
  saldo?: number;
  banco?: Banco;
}

export class GetContaDtoListServiceResponse
  implements IGetContaDtoListServiceResponse
{
  data?: GetContaDto[] | undefined;
  success?: boolean;
  message?: string | undefined;

  constructor(data?: IGetContaDtoListServiceResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(GetContaDto.fromJS(item));
      }
      this.success = _data["success"];
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): GetContaDtoListServiceResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetContaDtoListServiceResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data) data["data"].push(item.toJSON());
    }
    data["success"] = this.success;
    data["message"] = this.message;
    return data;
  }
}

export interface IGetContaDtoListServiceResponse {
  data?: GetContaDto[] | undefined;
  success?: boolean;
  message?: string | undefined;
}

export class GetContaDtoServiceResponse implements IGetContaDtoServiceResponse {
  data?: GetContaDto;
  success?: boolean;
  message?: string | undefined;

  constructor(data?: IGetContaDtoServiceResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"]
        ? GetContaDto.fromJS(_data["data"])
        : <any>undefined;
      this.success = _data["success"];
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): GetContaDtoServiceResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetContaDtoServiceResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["data"] = this.data ? this.data.toJSON() : <any>undefined;
    data["success"] = this.success;
    data["message"] = this.message;
    return data;
  }
}

export interface IGetContaDtoServiceResponse {
  data?: GetContaDto;
  success?: boolean;
  message?: string | undefined;
}

export class GetDividaDto implements IGetDividaDto {
  id?: number;
  titulo?: string | undefined;
  nomeDevedor?: string | undefined;
  descricao?: string | undefined;
  valor?: number;
  dataVencimento?: Date;
  dataPagamento?: Date;
  tipoDivida?: TipoDivida;
  situacaoDivida?: SituacaoDivida;
  conta?: GetContaDto;

  constructor(data?: IGetDividaDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.titulo = _data["titulo"];
      this.nomeDevedor = _data["nomeDevedor"];
      this.descricao = _data["descricao"];
      this.valor = _data["valor"];
      this.dataVencimento = _data["dataVencimento"]
        ? new Date(_data["dataVencimento"].toString())
        : <any>undefined;
      this.dataPagamento = _data["dataPagamento"]
        ? new Date(_data["dataPagamento"].toString())
        : <any>undefined;
      this.tipoDivida = _data["tipoDivida"];
      this.situacaoDivida = _data["situacaoDivida"];
      this.conta = _data["conta"]
        ? GetContaDto.fromJS(_data["conta"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): GetDividaDto {
    data = typeof data === "object" ? data : {};
    let result = new GetDividaDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["titulo"] = this.titulo;
    data["nomeDevedor"] = this.nomeDevedor;
    data["descricao"] = this.descricao;
    data["valor"] = this.valor;
    data["dataVencimento"] = this.dataVencimento
      ? this.dataVencimento.toISOString()
      : <any>undefined;
    data["dataPagamento"] = this.dataPagamento
      ? this.dataPagamento.toISOString()
      : <any>undefined;
    data["tipoDivida"] = this.tipoDivida;
    data["situacaoDivida"] = this.situacaoDivida;
    data["conta"] = this.conta ? this.conta.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetDividaDto {
  id?: number;
  titulo?: string | undefined;
  nomeDevedor?: string | undefined;
  descricao?: string | undefined;
  valor?: number;
  dataVencimento?: Date;
  dataPagamento?: Date;
  tipoDivida?: TipoDivida;
  situacaoDivida?: SituacaoDivida;
  conta?: GetContaDto;
}

export class GetDividaDtoListServiceResponse
  implements IGetDividaDtoListServiceResponse
{
  data?: GetDividaDto[] | undefined;
  success?: boolean;
  message?: string | undefined;

  constructor(data?: IGetDividaDtoListServiceResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(GetDividaDto.fromJS(item));
      }
      this.success = _data["success"];
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): GetDividaDtoListServiceResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetDividaDtoListServiceResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data) data["data"].push(item.toJSON());
    }
    data["success"] = this.success;
    data["message"] = this.message;
    return data;
  }
}

export interface IGetDividaDtoListServiceResponse {
  data?: GetDividaDto[] | undefined;
  success?: boolean;
  message?: string | undefined;
}

export class GetDividaDtoServiceResponse
  implements IGetDividaDtoServiceResponse
{
  data?: GetDividaDto;
  success?: boolean;
  message?: string | undefined;

  constructor(data?: IGetDividaDtoServiceResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"]
        ? GetDividaDto.fromJS(_data["data"])
        : <any>undefined;
      this.success = _data["success"];
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): GetDividaDtoServiceResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetDividaDtoServiceResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["data"] = this.data ? this.data.toJSON() : <any>undefined;
    data["success"] = this.success;
    data["message"] = this.message;
    return data;
  }
}

export interface IGetDividaDtoServiceResponse {
  data?: GetDividaDto;
  success?: boolean;
  message?: string | undefined;
}

export class GetObjetivoDto implements IGetObjetivoDto {
  id?: number;
  titulo?: string | undefined;
  descricao?: string | undefined;
  valor?: number;
  situacaoObjetivo?: SituacaoObjetivo;
  conta?: GetContaDto;

  constructor(data?: IGetObjetivoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.titulo = _data["titulo"];
      this.descricao = _data["descricao"];
      this.valor = _data["valor"];
      this.situacaoObjetivo = _data["situacaoObjetivo"];
      this.conta = _data["conta"]
        ? GetContaDto.fromJS(_data["conta"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): GetObjetivoDto {
    data = typeof data === "object" ? data : {};
    let result = new GetObjetivoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["titulo"] = this.titulo;
    data["descricao"] = this.descricao;
    data["valor"] = this.valor;
    data["situacaoObjetivo"] = this.situacaoObjetivo;
    data["conta"] = this.conta ? this.conta.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetObjetivoDto {
  id?: number;
  titulo?: string | undefined;
  descricao?: string | undefined;
  valor?: number;
  situacaoObjetivo?: SituacaoObjetivo;
  conta?: GetContaDto;
}

export class GetObjetivoDtoListServiceResponse
  implements IGetObjetivoDtoListServiceResponse
{
  data?: GetObjetivoDto[] | undefined;
  success?: boolean;
  message?: string | undefined;

  constructor(data?: IGetObjetivoDtoListServiceResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(GetObjetivoDto.fromJS(item));
      }
      this.success = _data["success"];
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): GetObjetivoDtoListServiceResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetObjetivoDtoListServiceResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data) data["data"].push(item.toJSON());
    }
    data["success"] = this.success;
    data["message"] = this.message;
    return data;
  }
}

export interface IGetObjetivoDtoListServiceResponse {
  data?: GetObjetivoDto[] | undefined;
  success?: boolean;
  message?: string | undefined;
}

export class GetObjetivoDtoServiceResponse
  implements IGetObjetivoDtoServiceResponse
{
  data?: GetObjetivoDto;
  success?: boolean;
  message?: string | undefined;

  constructor(data?: IGetObjetivoDtoServiceResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"]
        ? GetObjetivoDto.fromJS(_data["data"])
        : <any>undefined;
      this.success = _data["success"];
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): GetObjetivoDtoServiceResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetObjetivoDtoServiceResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["data"] = this.data ? this.data.toJSON() : <any>undefined;
    data["success"] = this.success;
    data["message"] = this.message;
    return data;
  }
}

export interface IGetObjetivoDtoServiceResponse {
  data?: GetObjetivoDto;
  success?: boolean;
  message?: string | undefined;
}

export class GetOperacaoDto implements IGetOperacaoDto {
  id?: number;
  titulo?: string | undefined;
  descricao?: string | undefined;
  valor?: number;
  dataOperacao?: Date | undefined;
  tipoOperacao?: TipoOperacao;
  conta?: GetContaDto;

  constructor(data?: IGetOperacaoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.titulo = _data["titulo"];
      this.descricao = _data["descricao"];
      this.valor = _data["valor"];
      this.dataOperacao = _data["dataOperacao"]
        ? new Date(_data["dataOperacao"].toString())
        : <any>undefined;
      this.tipoOperacao = _data["tipoOperacao"];
      this.conta = _data["conta"]
        ? GetContaDto.fromJS(_data["conta"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): GetOperacaoDto {
    data = typeof data === "object" ? data : {};
    let result = new GetOperacaoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["titulo"] = this.titulo;
    data["descricao"] = this.descricao;
    data["valor"] = this.valor;
    data["dataOperacao"] = this.dataOperacao
      ? this.dataOperacao.toISOString()
      : <any>undefined;
    data["tipoOperacao"] = this.tipoOperacao;
    data["conta"] = this.conta ? this.conta.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetOperacaoDto {
  id?: number;
  titulo?: string | undefined;
  descricao?: string | undefined;
  valor?: number;
  dataOperacao?: Date | undefined;
  tipoOperacao?: TipoOperacao;
  conta?: GetContaDto;
}

export class GetOperacaoDtoListServiceResponse
  implements IGetOperacaoDtoListServiceResponse
{
  data?: GetOperacaoDto[] | undefined;
  success?: boolean;
  message?: string | undefined;

  constructor(data?: IGetOperacaoDtoListServiceResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(GetOperacaoDto.fromJS(item));
      }
      this.success = _data["success"];
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): GetOperacaoDtoListServiceResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetOperacaoDtoListServiceResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data) data["data"].push(item.toJSON());
    }
    data["success"] = this.success;
    data["message"] = this.message;
    return data;
  }
}

export interface IGetOperacaoDtoListServiceResponse {
  data?: GetOperacaoDto[] | undefined;
  success?: boolean;
  message?: string | undefined;
}

export class GetOperacaoDtoServiceResponse
  implements IGetOperacaoDtoServiceResponse
{
  data?: GetOperacaoDto;
  success?: boolean;
  message?: string | undefined;

  constructor(data?: IGetOperacaoDtoServiceResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"]
        ? GetOperacaoDto.fromJS(_data["data"])
        : <any>undefined;
      this.success = _data["success"];
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): GetOperacaoDtoServiceResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetOperacaoDtoServiceResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["data"] = this.data ? this.data.toJSON() : <any>undefined;
    data["success"] = this.success;
    data["message"] = this.message;
    return data;
  }
}

export interface IGetOperacaoDtoServiceResponse {
  data?: GetOperacaoDto;
  success?: boolean;
  message?: string | undefined;
}

export class Int32ServiceResponse implements IInt32ServiceResponse {
  data?: number;
  success?: boolean;
  message?: string | undefined;

  constructor(data?: IInt32ServiceResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"];
      this.success = _data["success"];
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): Int32ServiceResponse {
    data = typeof data === "object" ? data : {};
    let result = new Int32ServiceResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["data"] = this.data;
    data["success"] = this.success;
    data["message"] = this.message;
    return data;
  }
}

export interface IInt32ServiceResponse {
  data?: number;
  success?: boolean;
  message?: string | undefined;
}

export class PagarDividaDto implements IPagarDividaDto {
  contaId?: number | undefined;
  dataPagamento?: Date | undefined;

  constructor(data?: IPagarDividaDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.contaId = _data["contaId"];
      this.dataPagamento = _data["dataPagamento"]
        ? new Date(_data["dataPagamento"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): PagarDividaDto {
    data = typeof data === "object" ? data : {};
    let result = new PagarDividaDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["contaId"] = this.contaId;
    data["dataPagamento"] = this.dataPagamento
      ? this.dataPagamento.toISOString()
      : <any>undefined;
    return data;
  }
}

export interface IPagarDividaDto {
  contaId?: number | undefined;
  dataPagamento?: Date | undefined;
}

export enum SituacaoDivida {
  Ativa = "Ativa",
  Paga = "Paga",
}

export enum SituacaoObjetivo {
  Não_Cumprido = "Não_Cumprido",
  Cumprido = "Cumprido",
}

export class StringServiceResponse implements IStringServiceResponse {
  data?: string | undefined;
  success?: boolean;
  message?: string | undefined;

  constructor(data?: IStringServiceResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"];
      this.success = _data["success"];
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): StringServiceResponse {
    data = typeof data === "object" ? data : {};
    let result = new StringServiceResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["data"] = this.data;
    data["success"] = this.success;
    data["message"] = this.message;
    return data;
  }
}

export interface IStringServiceResponse {
  data?: string | undefined;
  success?: boolean;
  message?: string | undefined;
}

export enum TipoDivida {
  Gasto = "Gasto",
  Recebimento = "Recebimento",
}

export enum TipoOperacao {
  Gasto = "Gasto",
  Recebimento = "Recebimento",
  Transferência = "Transferência",
}

export class UpdateContaDto implements IUpdateContaDto {
  id?: number;
  titulo?: string | undefined;
  saldo?: number;
  banco?: Banco;

  constructor(data?: IUpdateContaDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.titulo = _data["titulo"];
      this.saldo = _data["saldo"];
      this.banco = _data["banco"];
    }
  }

  static fromJS(data: any): UpdateContaDto {
    data = typeof data === "object" ? data : {};
    let result = new UpdateContaDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["titulo"] = this.titulo;
    data["saldo"] = this.saldo;
    data["banco"] = this.banco;
    return data;
  }
}

export interface IUpdateContaDto {
  id?: number;
  titulo?: string | undefined;
  saldo?: number;
  banco?: Banco;
}

export class UpdateDividaDto implements IUpdateDividaDto {
  id?: number;
  titulo?: string | undefined;
  nomeDevedor?: string | undefined;
  descricao?: string | undefined;
  valor?: number;
  dataVencimento?: Date | undefined;
  dataPagamento?: Date | undefined;
  tipoDivida?: TipoDivida;

  constructor(data?: IUpdateDividaDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.titulo = _data["titulo"];
      this.nomeDevedor = _data["nomeDevedor"];
      this.descricao = _data["descricao"];
      this.valor = _data["valor"];
      this.dataVencimento = _data["dataVencimento"]
        ? new Date(_data["dataVencimento"].toString())
        : <any>undefined;
      this.dataPagamento = _data["dataPagamento"]
        ? new Date(_data["dataPagamento"].toString())
        : <any>undefined;
      this.tipoDivida = _data["tipoDivida"];
    }
  }

  static fromJS(data: any): UpdateDividaDto {
    data = typeof data === "object" ? data : {};
    let result = new UpdateDividaDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["titulo"] = this.titulo;
    data["nomeDevedor"] = this.nomeDevedor;
    data["descricao"] = this.descricao;
    data["valor"] = this.valor;
    data["dataVencimento"] = this.dataVencimento
      ? this.dataVencimento.toISOString()
      : <any>undefined;
    data["dataPagamento"] = this.dataPagamento
      ? this.dataPagamento.toISOString()
      : <any>undefined;
    data["tipoDivida"] = this.tipoDivida;
    return data;
  }
}

export interface IUpdateDividaDto {
  id?: number;
  titulo?: string | undefined;
  nomeDevedor?: string | undefined;
  descricao?: string | undefined;
  valor?: number;
  dataVencimento?: Date | undefined;
  dataPagamento?: Date | undefined;
  tipoDivida?: TipoDivida;
}

export class UpdateObjetivoDto implements IUpdateObjetivoDto {
  id?: number;
  titulo?: string | undefined;
  descricao?: string | undefined;
  valor?: number;

  constructor(data?: IUpdateObjetivoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.titulo = _data["titulo"];
      this.descricao = _data["descricao"];
      this.valor = _data["valor"];
    }
  }

  static fromJS(data: any): UpdateObjetivoDto {
    data = typeof data === "object" ? data : {};
    let result = new UpdateObjetivoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["titulo"] = this.titulo;
    data["descricao"] = this.descricao;
    data["valor"] = this.valor;
    return data;
  }
}

export interface IUpdateObjetivoDto {
  id?: number;
  titulo?: string | undefined;
  descricao?: string | undefined;
  valor?: number;
}

export class UpdateOperacaoDto implements IUpdateOperacaoDto {
  id?: number;
  titulo?: string | undefined;
  descricao?: string | undefined;
  valor?: number;
  dataOperacao?: Date | undefined;
  tipoOperacao?: TipoOperacao;

  constructor(data?: IUpdateOperacaoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.titulo = _data["titulo"];
      this.descricao = _data["descricao"];
      this.valor = _data["valor"];
      this.dataOperacao = _data["dataOperacao"]
        ? new Date(_data["dataOperacao"].toString())
        : <any>undefined;
      this.tipoOperacao = _data["tipoOperacao"];
    }
  }

  static fromJS(data: any): UpdateOperacaoDto {
    data = typeof data === "object" ? data : {};
    let result = new UpdateOperacaoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["titulo"] = this.titulo;
    data["descricao"] = this.descricao;
    data["valor"] = this.valor;
    data["dataOperacao"] = this.dataOperacao
      ? this.dataOperacao.toISOString()
      : <any>undefined;
    data["tipoOperacao"] = this.tipoOperacao;
    return data;
  }
}

export interface IUpdateOperacaoDto {
  id?: number;
  titulo?: string | undefined;
  descricao?: string | undefined;
  valor?: number;
  dataOperacao?: Date | undefined;
  tipoOperacao?: TipoOperacao;
}

export class UsuarioLoginDto implements IUsuarioLoginDto {
  email?: string | undefined;
  password?: string | undefined;

  constructor(data?: IUsuarioLoginDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data["email"];
      this.password = _data["password"];
    }
  }

  static fromJS(data: any): UsuarioLoginDto {
    data = typeof data === "object" ? data : {};
    let result = new UsuarioLoginDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["email"] = this.email;
    data["password"] = this.password;
    return data;
  }
}

export interface IUsuarioLoginDto {
  email?: string | undefined;
  password?: string | undefined;
}

export class UsuarioRegisterDto implements IUsuarioRegisterDto {
  nome?: string | undefined;
  email?: string | undefined;
  password?: string | undefined;

  constructor(data?: IUsuarioRegisterDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.nome = _data["nome"];
      this.email = _data["email"];
      this.password = _data["password"];
    }
  }

  static fromJS(data: any): UsuarioRegisterDto {
    data = typeof data === "object" ? data : {};
    let result = new UsuarioRegisterDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["nome"] = this.nome;
    data["email"] = this.email;
    data["password"] = this.password;
    return data;
  }
}

export interface IUsuarioRegisterDto {
  nome?: string | undefined;
  email?: string | undefined;
  password?: string | undefined;
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
  return obj && obj.isAxiosError === true;
}
